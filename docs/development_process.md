# 開発プロセス

## 開発環境セットアップ

### 開発コマンド
```bash
# 開発
npm run dev          # 開発サーバー起動（Turbopack使用）
npm run build        # プロダクションビルド
npm run start        # プロダクションサーバー起動

# コード品質
npm run lint         # ESLint実行
npm test            # 全テスト実行
npx tsc --noEmit    # 型チェック（ファイル出力なし）

# データベース
npx prisma migrate dev    # マイグレーション実行
npx prisma studio        # Prisma Studio起動（DB確認用）
npx prisma generate      # Prisma Client生成

# E2Eテスト

## 🚀 基本実行
npm run e2e              # 全E2Eテストを並列実行（推奨）
npm run e2e:with-report  # テスト実行後にHTMLレポートを表示

## 🌐 ブラウザ別実行（開発時のみ推奨）
npm run e2e:chrome       # Chromiumのみで実行（最速）
npm run e2e:cross-browser # 主要ブラウザで実行

## 📋 機能別実行（必要な場合のみ）
npm run e2e:smoke        # スモークテストのみ
npm run e2e:master       # マスターデータ機能のみ
npm run e2e:materials    # 素材管理機能のみ
npm run e2e:workflows    # ワークフローテストのみ

## 🔍 デバッグ・詳細実行
npm run e2e:ui           # UIモードでデバッグ
npm run e2e:debug        # デバッグモード
npm run e2e:report       # 最後のテストレポートを表示

# 特定のテストを実行
npm run e2e -- --grep "Equipment.*validation"

## ⚠️ 注意事項
- `npm run e2e` は並列実行により高速化されています
- CI環境では自動的に同時実行プロセスが1に制限されます
- 段階的実行は特定の機能のみをテストしたい場合に使用してください

## データベース管理
npm run e2e:db:create    # E2Eテストデータベース作成
npm run e2e:db:migrate   # マイグレーション実行
npm run e2e:db:seed      # テストデータ投入
npm run e2e:db:drop      # データベース削除
npm run e2e:db:setup     # 完全セットアップ
```

### アーキテクチャ概要
- **Framework**: Next.js 15 (App Router)
- **Language**: TypeScript
- **Database**: PostgreSQL + Prisma ORM
- **State Management**: Jotai
- **Data Fetching**: TanStack Query
- **UI Components**: shadcn/ui + Radix UI
- **Styling**: Tailwind CSS
- **Testing**: Jest + React Testing Library
- **E2E Testing**: Playwright
- **Background Jobs**: BullMQ + Redis

### ディレクトリ構造
- `/src/app/` - Next.js App Router
  - `(app)/` - アプリケーションページ（共通レイアウト）
  - `(api)/` - APIルートグループ
- `/src/components/` - Reactコンポーネント（機能別）
- `/src/lib/` - ユーティリティ・共通ロジック
- `/src/types/` - TypeScript型定義
- `/prisma/` - DBスキーマ・マイグレーション
- `/docs/` - プロジェクトドキュメント
- `/e2e/` - E2Eテスト（Playwright）
  - `fixtures/` - テスト設定とカスタムフィクスチャ
  - `helpers/` - 共通操作用の再利用可能なテストヘルパークラス
  - `tests/` - 機能エリア別に整理されたテストファイル
    - `master/` - マスターデータ管理テスト（Equipment, Tags）
    - `materials/` - 素材CRUD・一覧テスト
    - `workflows/` - 複雑なユーザージャーニーと統合テスト
- `/scripts/` - E2Eテストインフラストラクチャ
  - `e2e-db-setup.ts` - E2Eデータベースライフサイクル管理
  - `run-e2e-with-db.ts` - 分離されたデータベースでのE2Eテスト実行
  - `seed-test-data.ts` - 多言語コンテンツを含むテストデータ管理

### データベーススキーマ
主要エンティティ：
- **Material**: 音声録音と関連メタデータ
- **Project**: 素材のグループ
- **Tag**: カテゴリ分類用ラベル
- **Equipment**: 録音機材マスタデータ

多対多リレーション: materials ↔ projects/tags/equipment

## 開発プロセス詳細

1. 指示の分析と計画
  - GitHub の issues には、対応しなければならない開発タスクが登録されています
  - ユーザが優先度の高いタスクを実行するように指示した場合は、この issues から `priority: {critical|high|medium|low}` のタグから優先度が高い順にを参照したうえで、タスクを選択してください
  - 主要なタスクを簡潔に要約してください。
  - `docs` ディレクトリ以下の各種ドキュメントを確認し、その制約内での実装方法を検討してください。 **技術スタックに記載のバージョンは変更せず、必要があれば必ず承認を得てください。**
  - 重要な要件と制約を特定してください。
  - 潜在的な課題をリストアップしてください。
  - タスク実行のための具体的なステップを詳細に列挙してください。
  - それらのステップの最適な実行順序を決定してください。
  - 実装前に以下の確認を行ってください
    - 既存の類似機能の有無
    - 同名または類似名の関数やコンポーネント
    - 重複する API エンドポイント
    - 共通化可能な処理の特定

  このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。

### 設計パターン

1. **APIルート**: `/src/app/api/` 配下でRESTful規約に従う
2. **コンポーネント構造**: 機能別に整理（materials, master等）
3. **フォーム処理**: react-hook-form + zod検証
4. **テスト**: 各コンポーネント・APIルートに対応するテストファイル

2. タスクの実行
  - 最新のmainブランチを取得してから作業を開始します：
    ```bash
    git checkout main
    git pull origin main
    ```
  - 実装を開始するため、ブランチを作成します。ブランチ命名規則：
    - feature/issue-{番号}-{簡潔な説明}  （新機能）
    - fix/issue-{番号}-{簡潔な説明}     （バグ修正）
    - test/issue-{番号}-{簡潔な説明}    （テスト追加）
    - refactor/issue-{番号}-{簡潔な説明}（リファクタリング）
  - **重要**: mainブランチへの直接コミット・プッシュは禁止です。必ず別ブランチで作業し、PRを経由してください。
  - 実装前にissueのステータスを「status: in progress」に更新します。
  - TodoWriteツールでタスク管理を行います（タスクの追跡と進捗管理のため推奨）。
  - 特定したステップを一つずつ実行してください。
  - テストをパスした時点でコミットを作成します。テストをパスしていないコードをコミットしてはいけません。
  - 各ステップの完了後、簡潔に進捗を報告してください。
  - 実装時は以下の点に注意してください：
    - 適切なディレクトリ構造の遵守
    - 命名規則の一貫性維持
    - 共通処理の適切な配置
  - TDD を実施してください。コードを生成するときは、それに対応するユニットテストを常に生成してください。コードを追加で修正したとき、`npm test` がパスすることを常に確認してください
    ```ts
    function add(a: number, b: number) {
      return a + b;
    }
    test("1+2=3", () => {
      expect(add(1, 2)).toBe(3);
    });
    ```
   - テストカバレッジ 100%を目指します。`*.ts` に対して、`*.test.ts` でユニットテストを書いてください
   - test.ts がない実装に対して、他のテストを参考にテストコードを追加してください
     1. `npm test` を実行して、現在のカバレッジを取得
     2. 今の状態から最もカバレッジが上がるテストコードを考察してから追加
     3. 再度カバレッジを計測して、数値が向上していることを確認
     4. **重要**: 全てのテストに成功し、Statements, Branches, Functions, Lines の各カバレッジが80%を超えていないとマージが出来ないため、超えるまでテストの追加とテスト実行を繰り返す
   - **テストベストプラクティス**: テストを書く・修正する際は、必ず `docs/testing_best_practices.md` のガイドラインに従ってください：
     - ユーザー中心のテストを書く（実装の詳細ではなく観察可能な動作に焦点）
     - 適切なモッキング戦略を使用
     - TDDの原則を正しく適用
   - **E2Eテストの保守**: UI や操作フローを変更した場合は、必ず関連する E2E テストも更新してください：
     - HTML構造を変更した場合はセレクターを更新
     - 操作フローを変更した場合はテストステップを更新
     - 新機能には対応するE2Eテストを追加（適切なカテゴリ：master/, materials/, workflows/）
     - **重要: テストタグの付与** - 新しいテストには必ず適切なタグを付ける：
       - `@smoke` - 基本動作確認用の重要なテスト
       - `@master` - マスターデータ機能のテスト
       - `@materials` - 素材管理機能のテスト
       - `@workflow` - 統合ワークフローのテスト
       - `@critical` - 絶対に失敗してはいけない重要テスト
     - **テスト実行戦略**：
       - 開発中: 変更したテストのみ実行 `npm run e2e -- --grep "test-name"`
       - コミット前: 全E2Eテスト実行 `npm run e2e` または関連機能のみ（例: `npm run e2e:materials`）
       - PR作成前: 全E2Eテスト実行 `npm run e2e`（推奨）
     - 削除した機能のE2Eテストは削除
     - 共通パターンが変更された場合は `/e2e/helpers/` のヘルパークラスを更新
     - データモデル変更時はシードデータとワークフローテストの両方を更新

3. 品質管理と問題対応
  - 各タスクの実行結果を迅速に検証してください。
  - **重要**: プッシュ前に必ず以下のすべての品質チェックを実施してください。1つでも失敗した場合は、修正してから再度すべてのチェックを行ってください：
    - [ ] `npm test` - 全テストがパス
    - [ ] `npm run lint` - lintエラーなし
    - [ ] `npx tsc --noEmit` - 型エラーなし
    - [ ] `npm run dev` - 開発サーバー起動確認
    - [ ] 全てのカバレッジ指標（Statements, Branches, Functions, Lines）が80%を超えている
    - [ ] UI変更時は関連するE2Eテストを更新
  - **プッシュ前の必須確認**: GitHub Actions と同等のローカルテストをすべて実施してください。CIで失敗すると手戻りが大きいため、以下のコマンドをすべて成功させてからプッシュしてください：
    ```bash
    # 1. CI環境と同じ条件でテストを実行
    DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db NODE_ENV=test npm test -- --coverage --watchAll=false
    
    # 2. ビルドの確認（CI環境相当）- 特に重要：useSearchParams等のNext.js固有のエラーを検出
    DATABASE_URL=postgresql://user:password@localhost:5432/dummy_db npm run build
    
    # 3. Lint & 型チェック
    npm run lint && npx tsc --noEmit
    
    # 4. セキュリティ監査
    npm audit --audit-level=moderate
    
    # 5. E2Eテスト
    # 全E2Eテストを実行（推奨）
    npm run e2e
    
    # または、変更した機能のみテスト（高速化したい場合）
    npm run e2e:smoke       # 基本動作確認（必須）
    npm run e2e:master      # マスターデータ変更時
    npm run e2e:materials   # 素材管理変更時
    npm run e2e:workflows   # ワークフロー変更時
    ```
  - **ビルドエラーの事前チェック**:
    - Next.js 15では`useSearchParams()`をSuspense boundaryでラップする必要があります
    - 動的インポートやサーバーサイドレンダリングに関するエラーに注意
    - CI環境特有の問題（ロケール依存の日付フォーマット等）を考慮
  - **よくあるCI失敗パターン**:
    - `useSearchParams()` がSuspense boundaryでラップされていない
    - 日付フォーマットのロケール間の違い（柔軟なパターンを使用）
    - ESModuleインポート問題（jest.config.jsのtransformIgnorePatternsを確認）
    - テスト環境でのRedis/BullMQの初期化
  - タスク内で発生したエラーについては確実に解決していることを確認してください。
  - 実施したタスク外で発生している既存のエラーについては、GitHub の issue を確認し、該当する対応用 issue が作成されていない場合はステップ 8 で追加してください。
  - エラーや不整合が発生した場合は、以下のプロセスで対応してください：
    - 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
    - 対策案の作成と実施
    - 修正後の動作検証
    - デバッグログの確認と分析
  - 検証結果は以下の形式で記録してください
    - 検証項目と期待される結果
    - 実際の結果と差異
    - 必要な対応策（該当する場合）

## コード規約

- TypeScript strict modeを使用
- 既存のコンポーネント構造パターンに従う
- パスエイリアス（`@/` でsrcディレクトリ）を使用
- APIルートでは適切なエラーハンドリングを実装
- コミット前にデバッグコードとconsole.logを削除

## 品質チェックリスト

**プッシュ前**の必須確認（CIで失敗すると手戻りが大きいため）：
- [ ] CI環境想定のテスト成功（`DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db NODE_ENV=test npm test -- --coverage --watchAll=false`）
- [ ] ビルド成功（`DATABASE_URL=postgresql://user:password@localhost:5432/dummy_db npm run build`）
- [ ] lintと型チェック成功（`npm run lint && npx tsc --noEmit`）
- [ ] セキュリティ監査パス（`npm audit --audit-level=moderate`）

PRを作成する前に確認：
- [ ] 全テストがパス（`npm test`）
- [ ] lintエラーなし（`npm run lint`）
- [ ] 型エラーなし（`npx tsc --noEmit`）
- [ ] 開発サーバーが正常起動（`npm run dev`）
- [ ] 全カバレッジ指標（Statements, Branches, Functions, Lines）が80%超
- [ ] 新規ファイルには対応するテストファイルを作成
- [ ] UI/フロー変更時はE2Eテストを更新済み
- [ ] E2Eテストがパス（`npm run e2e` または変更した機能のみ: `npm run e2e:smoke`, `npm run e2e:master`, `npm run e2e:materials`, `npm run e2e:workflows`）
- [ ] 新規E2Eテストには適切なタグを付与（@smoke, @master, @materials, @workflow, @critical）

## 重要な注意事項

- 技術スタックのバージョンは承認なしに変更しない
- 既存の類似機能を確認し、重複実装を避ける
- UI/UXデザイン変更は事前承認が必要
- 指示されたら docs/issues.md のissueに対処
- 開発中に発見した問題は GitHub issue を作成

## E2Eテスト管理とスクリプト

`scripts/` ディレクトリには、開発中にメンテナンスが必要なE2Eテストの重要なインフラストラクチャが含まれています。

### E2Eインフラストラクチャを更新するタイミング

**データベーススキーマ変更時** 🗄️
- **条件**: Prismaモデル、フィールド、リレーションシップを追加・修正する場合
- **対応**: `seed-test-data.ts` を更新して新しいフィールドと現実的なテストデータを含める
- **例**: 新しいMaterialフィールドには対応するテストデータエントリが必要

**新機能実装時** 🚀
- **条件**: 新しいページ、コンポーネント、ユーザーフローを追加する場合
- **対応**:
  1. 適切なディレクトリ（`/e2e/tests/`）に対応するE2Eテストを追加
  2. 新しいエンティティタイプが必要な場合はシードデータを更新
  3. 新しいユーザージャーニー用のワークフローテストを更新

**UI構造変更時** 🎨
- **条件**: HTML構造、CSSクラス、コンポーネント階層を変更する場合
- **対応**: E2Eテストとヘルパークラスのセレクターを更新
- **重要**: フォームフィールド、ボタン、ナビゲーション要素の変更

**APIエンドポイント変更時** 🔧
- **条件**: APIルート、リクエスト/レスポンス形式、バリデーションを修正する場合
- **対応**: これらのエンドポイントと対話する対応するE2Eテストを更新

### E2Eテストメンテナンスチェックリスト

変更時に確認：
- [ ] シードデータに新機能のテストケースを含める
- [ ] テストセレクターが更新されたUI構造と一致
- [ ] ワークフローテストが新しいユーザーパスをカバー
- [ ] 未実装機能のスキップテストが適切にマーク
- [ ] テストデータに多様なコンテンツ（多言語、エッジケース）を含む

### テストデータ戦略

シードデータの設計：
- **多言語コンテンツ**: 日本語、英語、絵文字の組み合わせ
- **現実的なシナリオ**: 実世界のフィールドレコーディング例
- **エッジケース**: 様々なデータ形式、長さ、タイプ
- **リレーションシップ**: 包括的なテストのための複雑な多対多関連

### E2E問題のデバッグ

一般的なシナリオと解決策：
- **データベース接続問題**: PostgreSQLサービスと認証情報を確認
- **ポート競合**: スクリプトが自動でポート競合を検出・適応
- **タイミング問題**: 必要に応じて `run-e2e-with-db.ts` のタイムアウトを増加
- **シードデータ失敗**: Prismaスキーマとシードスクリプトの互換性を確認

### パフォーマンス考慮事項
- 分離を確保するため、各テスト実行でE2Eデータベースを再作成
- 高速シード用に最適化されたテストデータ（約21素材、8機材、8タグ）
- 自動テスト実行のための開発サーバー起動監視

### E2Eテストのタグ付けベストプラクティス

新しいE2Eテストを作成する際は、以下のようにタグを付けてください：

```typescript
// スモークテストの例
test.describe('@smoke @critical Simple Functionality Check', () => {
  test('Application starts up', async ({ page }) => {
    // 基本的な起動確認
  });
});

// 機能テストの例
test.describe('@materials Create Material', () => {
  test('can create a valid material', async ({ page }) => {
    // 素材作成のテスト
  });
});

// ワークフローテストの例
test.describe('@workflow Complete User Journey', () => {
  test('新規ユーザーの素材管理完全フロー', async ({ page }) => {
    // 統合的なユーザーフロー
  });
});
```

**タグの使い分け**：
- `@smoke`: アプリケーションの基本動作を確認する最小限のテスト
- `@critical`: 絶対に失敗してはいけない重要な機能のテスト
- `@master`: 機材・タグなどのマスターデータ管理機能
- `@materials`: 素材の作成・編集・一覧表示などの機能
- `@workflow`: 複数機能にまたがる統合的なユーザーフロー

複数のタグを組み合わせることも可能です（例: `@smoke @critical`）。

## バックグラウンドジョブ

ZIPファイル生成などのバックグラウンドタスクにBullMQを使用。ジョブキュー管理にはRedisが必要。

4. 最終確認
  - すべてのタスクが完了したら、成果物全体を評価してください。
  - 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。
  - 実装した機能に重複がないことを最終確認してください。
5. 結果報告
  以下のフォーマットで最終的な結果をまとめた上で、GitHub に Pull Request を作成します。Pull Request の作成にあたっては、該当する issue を関連付けます。PR本文には必ず `Closes #[issue番号]` を含めてください。

  ```markdown
  # {実施したタスク名}

  ## 概要

  [全体の要約を簡潔に記述]

  ## 実行ステップ

  1. [ステップ 1 の説明と結果]
  2. [ステップ 2 の説明と結果]
  ...

  ## 最終成果物

  [成果物の詳細や、該当する場合はリンクなど]

  ## 課題対応（該当する場合）

  - 発生した問題と対応内容
  - 今後の注意点

  ## 関連issue
  - Closes #[issue番号]

  ```

6. ユーザへの動作確認依頼
  ここまで完了したら、以下のセルフチェックを行った上で、ユーザにレビュー、及び動作確認の依頼をしてください。

  ## セルフチェックリスト
  - [ ] 新規ファイルにはテストファイルも作成済み
  - [ ] 全てのカバレッジ指標（Statements, Branches, Functions, Lines）が80%を超えている
  - [ ] 不要なconsole.logやデバッグコードを削除済み
  - [ ] CLAUDE.mdの更新が必要な場合は更新済み
  - [ ] UI/フロー変更時は関連するE2Eテストを更新済み

  以下のフォーマットで依頼します。

  ```markdown
  # 動作確認依頼

  ## [ユーザに確認してほしい操作の表題]

  1. [ユーザに確認してほしい操作をステップを分割して具体的に書く]
  2. [ユーザに確認してほしい操作をステップを分割して具体的に書く]
  ...

  ## ユーザから特にフィードバックを受けたいこと

  [ユーザからのフィードバックを受けたい場合(ログ出力結果の共有依頼、挙動の正常性確認など)があれば書く]
  ```

  `npm run dev` で開発サーバをします。コンパイルエラーが起きず、正しく起動することを確認してください。ユーザから不具合が報告された場合は、コードを修正し不具合を解消するとともに、不具合の内容をユニットテストの新たなエッジケースとして追加してください。その後、「3. 品質管理と問題対応」からステップをやり直します。

7. Pull Request のマージ
  - ユーザーがレビューと動作確認を完了し、自身でPull Requestをマージします
  - Claudeはマージを行いません

8. タスク実行中に発生した課題の起票
  - タスク実行中に、改善したほうがよいことや問題を発見した場合は、GitHub に issue を作成します
  - 作成する issue の本文には以下を必ず含めます
    - 対象箇所
    - 問題点
    - 対応方針
    - 関連情報
    - 受け入れ条件
  - issue には適切な label を付与します。label 一覧を確認し、適切な label を選択してください

9. タスクの完了
  上記の実行が終了したら、一連のタスクは完了です。ユーザーに次の指示を仰いで下さい
